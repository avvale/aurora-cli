/**
 * Aurora Tools Scripts Templates
 *
 * Copiar y adaptar estos templates para crear migrations y procedures.
 * Reemplazar los placeholders {TableName}, {columnName}, etc.
 */

import {
  ToolsCreateMigrationTemplateInput,
  ToolsCreateProcedureTemplateInput,
  ToolsProcedureType,
} from '@api/graphql';

// ============================================
// MIGRATION TEMPLATES
// ============================================

export const migrationTemplates: Partial<ToolsCreateMigrationTemplateInput>[] =
  [
    // Template: Add Column
    {
      id: 'GENERATE-UUID',
      name: 'Add {columnName} to {TableName}',
      version: 'X.X.X',
      sort: 1,
      upScript: `
      ALTER TABLE public."{TableName}" ADD COLUMN "{columnName}" {TYPE} {NULL|NOT NULL} {DEFAULT value};
    `,
      downScript: `
      ALTER TABLE public."{TableName}" DROP COLUMN IF EXISTS "{columnName}";
    `,
    },

    // Template: Add Multiple Columns
    {
      id: 'GENERATE-UUID',
      name: 'Add {col1} and {col2} to {TableName}',
      version: 'X.X.X',
      sort: 1,
      upScript: `
      ALTER TABLE public."{TableName}" ADD COLUMN "{col1}" {TYPE1} {NULL|NOT NULL};
      ALTER TABLE public."{TableName}" ADD COLUMN "{col2}" {TYPE2} {NULL|NOT NULL} DEFAULT {value};
    `,
      downScript: `
      ALTER TABLE public."{TableName}" DROP COLUMN IF EXISTS "{col1}";
      ALTER TABLE public."{TableName}" DROP COLUMN IF EXISTS "{col2}";
    `,
    },

    // Template: Drop Column
    {
      id: 'GENERATE-UUID',
      name: 'Drop {columnName} in {TableName}',
      version: 'X.X.X',
      sort: 1,
      upScript: `
      ALTER TABLE public."{TableName}" DROP COLUMN IF EXISTS "{columnName}";
    `,
      downScript: `
      ALTER TABLE public."{TableName}" ADD COLUMN "{columnName}" {TYPE} {NULL|NOT NULL};
    `,
    },

    // Template: Rename Column
    {
      id: 'GENERATE-UUID',
      name: 'Rename {oldName} to {newName} in {TableName}',
      version: 'X.X.X',
      sort: 1,
      upScript: `
      ALTER TABLE public."{TableName}" RENAME COLUMN "{oldName}" TO "{newName}";
    `,
      downScript: `
      ALTER TABLE public."{TableName}" RENAME COLUMN "{newName}" TO "{oldName}";
    `,
    },

    // Template: Rename Column with Type Change
    {
      id: 'GENERATE-UUID',
      name: 'Rename {oldName} to {newName} in {TableName}',
      version: 'X.X.X',
      sort: 1,
      upScript: `
      ALTER TABLE public."{TableName}" RENAME COLUMN "{oldName}" TO "{newName}";
      ALTER TABLE public."{TableName}" ALTER COLUMN "{newName}" TYPE {NEW_TYPE};
    `,
      downScript: `
      ALTER TABLE public."{TableName}" RENAME COLUMN "{newName}" TO "{oldName}";
      ALTER TABLE public."{TableName}" ALTER COLUMN "{oldName}" TYPE {OLD_TYPE};
    `,
    },

    // Template: Add Index
    {
      id: 'GENERATE-UUID',
      name: 'Add index on {columnName} in {TableName}',
      version: 'X.X.X',
      sort: 1,
      upScript: `
      CREATE INDEX {table_name}_{column_name}_idx ON public."{TableName}" USING btree ("{columnName}");
    `,
      downScript: `
      DROP INDEX IF EXISTS "{table_name}_{column_name}_idx";
    `,
    },

    // Template: Add Unique Index
    {
      id: 'GENERATE-UUID',
      name: 'Add unique index on {columnName} in {TableName}',
      version: 'X.X.X',
      sort: 1,
      upScript: `
      CREATE UNIQUE INDEX {table_name}_{column_name}_idx ON public."{TableName}" USING btree ("{columnName}");
    `,
      downScript: `
      DROP INDEX IF EXISTS "{table_name}_{column_name}_idx";
    `,
    },

    // Template: Add rowId (Patrón estándar Aurora)
    // Este patrón agrega una columna rowId con IDENTITY y migra datos existentes
    {
      id: 'GENERATE-UUID',
      name: 'Add rowId to {TableName}',
      version: 'X.X.X',
      sort: 1,
      upScript: `
      ALTER TABLE public."{TableName}" ADD COLUMN "rowId" BIGINT GENERATED BY DEFAULT AS IDENTITY;
      WITH ordered AS (
          SELECT id AS uuid_pk, ROW_NUMBER() OVER (ORDER BY "createdAt", id) AS rn FROM public."{TableName}"
      )
      UPDATE public."{TableName}" t
          SET "rowId" = o.rn
      FROM ordered o
          WHERE t.id = o.uuid_pk
              AND t."rowId" IS NULL;

      SELECT setval(pg_get_serial_sequence('public."{TableName}"','rowId'), (SELECT MAX("rowId") FROM public."{TableName}"), true);

      ALTER TABLE public."{TableName}" ALTER COLUMN "rowId" SET NOT NULL;
      CREATE UNIQUE INDEX {table_name}_row_id ON public."{TableName}" USING btree ("rowId");
    `,
      downScript: `
      DROP INDEX IF EXISTS "{table_name}_row_id";
      ALTER TABLE public."{TableName}" DROP COLUMN IF EXISTS "rowId";
    `,
    },

    // Template: Change Column Type
    {
      id: 'GENERATE-UUID',
      name: 'Change {columnName} type in {TableName}',
      version: 'X.X.X',
      sort: 1,
      upScript: `
      ALTER TABLE public."{TableName}" ALTER COLUMN "{columnName}" TYPE {NEW_TYPE};
    `,
      downScript: `
      ALTER TABLE public."{TableName}" ALTER COLUMN "{columnName}" TYPE {OLD_TYPE};
    `,
    },

    // Template: Add NOT NULL constraint
    {
      id: 'GENERATE-UUID',
      name: 'Add NOT NULL to {columnName} in {TableName}',
      version: 'X.X.X',
      sort: 1,
      upScript: `
      ALTER TABLE public."{TableName}" ALTER COLUMN "{columnName}" SET NOT NULL;
    `,
      downScript: `
      ALTER TABLE public."{TableName}" ALTER COLUMN "{columnName}" DROP NOT NULL;
    `,
    },

    // Template: Add Default Value
    {
      id: 'GENERATE-UUID',
      name: 'Add default to {columnName} in {TableName}',
      version: 'X.X.X',
      sort: 1,
      upScript: `
      ALTER TABLE public."{TableName}" ALTER COLUMN "{columnName}" SET DEFAULT {value};
    `,
      downScript: `
      ALTER TABLE public."{TableName}" ALTER COLUMN "{columnName}" DROP DEFAULT;
    `,
    },
  ];

// ============================================
// PROCEDURE TEMPLATES
// ============================================

export const procedureTemplates: Partial<ToolsCreateProcedureTemplateInput>[] =
  [
    // Template: Basic Procedure
    {
      id: 'GENERATE-UUID',
      name: '{procedure_name}',
      type: ToolsProcedureType.PROCEDURE,
      version: 'X.X.X',
      sort: 1,
      upScript: `
CREATE OR REPLACE PROCEDURE {procedure_name}(param1 {TYPE}, param2 {TYPE})
LANGUAGE plpgsql
AS $$
BEGIN
    -- Logic here
END;
$$;
    `,
      downScript: `DROP PROCEDURE IF EXISTS {procedure_name}({TYPE}, {TYPE});`,
    },

    // Template: Basic Function
    {
      id: 'GENERATE-UUID',
      name: '{function_name}',
      type: ToolsProcedureType.FUNCTION,
      version: 'X.X.X',
      sort: 1,
      upScript: `
CREATE OR REPLACE FUNCTION {function_name}(param1 {TYPE})
RETURNS {RETURN_TYPE}
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN {result};
END;
$$;
    `,
      downScript: `DROP FUNCTION IF EXISTS {function_name}({TYPE});`,
    },

    // Template: Trigger Function
    {
      id: 'GENERATE-UUID',
      name: '{trigger_function_name}',
      type: ToolsProcedureType.FUNCTION,
      version: 'X.X.X',
      sort: 1,
      upScript: `
CREATE OR REPLACE FUNCTION {trigger_function_name}()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    -- Logic here
    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_{trigger_function_name} ON public."{TableName}";
CREATE TRIGGER trg_{trigger_function_name}
    BEFORE INSERT ON public."{TableName}"
    FOR EACH ROW EXECUTE FUNCTION {trigger_function_name}();
    `,
      downScript: `
DROP TRIGGER IF EXISTS trg_{trigger_function_name} ON public."{TableName}";
DROP FUNCTION IF EXISTS {trigger_function_name}();
    `,
    },

    // Template: Sequence with Idempotency
    {
      id: 'GENERATE-UUID',
      name: 'Create {sequence_name} sequence',
      type: ToolsProcedureType.FUNCTION, // Se usa FUNCTION para secuencias
      version: 'X.X.X',
      sort: 1, // Secuencias van primero (sort bajo)
      upScript: `
DO $$
BEGIN
    IF to_regclass('public.{sequence_name}_seq') IS NULL THEN
        CREATE SEQUENCE {sequence_name}_seq
            AS bigint
            START WITH 1
            INCREMENT BY 1
            NO MINVALUE
            NO MAXVALUE
            CACHE 1;
    END IF;
END
$$;
    `,
      downScript: `DROP SEQUENCE IF EXISTS {sequence_name}_seq;`,
    },

    // Template: Function + Trigger con código secuencial
    // Patrón: Generar código con prefijo + secuencia + sufijo de env var
    {
      id: 'GENERATE-UUID',
      name: 'Create set_{entity}_{field} function and trigger',
      type: ToolsProcedureType.FUNCTION,
      version: 'X.X.X',
      sort: 2, // Después de la secuencia
      upScript: `
CREATE OR REPLACE FUNCTION set_{entity}_{field}()
RETURNS trigger AS $
DECLARE
    t_counter bigint;
    v_code text;
BEGIN
    t_counter := nextval('{sequence_name}_seq');
    v_code := '{PREFIX}' || LPAD(t_counter::text, 6, '0') || '\${process.env.SUFFIX_VAR}';

    NEW."{fieldName}" := v_code;

    -- Opcional: UPDATE a tabla relacionada
    -- UPDATE "{RelatedTable}"
    -- SET "{relatedField}" = v_code
    -- WHERE "{fkField}" = NEW."{fkField}";

    RETURN NEW;
END;
$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_set_{entity}_{field} ON public."{TableName}";
CREATE TRIGGER trg_set_{entity}_{field}
BEFORE INSERT ON public."{TableName}"
FOR EACH ROW
EXECUTE FUNCTION set_{entity}_{field}();
    `,
      downScript: `
DROP TRIGGER IF EXISTS trg_set_{entity}_{field} ON public."{TableName}";
DROP FUNCTION IF EXISTS set_{entity}_{field}();
    `,
    },

    // Template: Audit Trigger (registro de cambios)
    {
      id: 'GENERATE-UUID',
      name: 'Create audit trigger for {TableName}',
      type: ToolsProcedureType.FUNCTION,
      version: 'X.X.X',
      sort: 1,
      upScript: `
CREATE OR REPLACE FUNCTION audit_{table_name}()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    IF TG_OP = 'UPDATE' THEN
        NEW."updatedAt" = NOW();
    END IF;
    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_audit_{table_name} ON public."{TableName}";
CREATE TRIGGER trg_audit_{table_name}
    BEFORE UPDATE ON public."{TableName}"
    FOR EACH ROW EXECUTE FUNCTION audit_{table_name}();
    `,
      downScript: `
DROP TRIGGER IF EXISTS trg_audit_{table_name} ON public."{TableName}";
DROP FUNCTION IF EXISTS audit_{table_name}();
    `,
    },
  ];

// ============================================
// EJEMPLO DE USO
// ============================================

/**
 * Ejemplo: Crear una migración para añadir columna 'priority' tipo INTEGER a tabla 'Order'
 *
 * 1. Copiar el template "Add Column"
 * 2. Generar UUID: crypto.randomUUID() o uuidgen en terminal
 * 3. Reemplazar placeholders:
 *    - {TableName} -> Order
 *    - {columnName} -> priority
 *    - {TYPE} -> INTEGER
 *    - {NULL|NOT NULL} -> NOT NULL
 *    - {DEFAULT value} -> DEFAULT 0
 * 4. Ajustar version al actual del proyecto
 * 5. Ajustar sort al siguiente disponible
 *
 * Resultado:
 */
const exampleMigration: ToolsCreateMigrationTemplateInput = {
  id: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890', // Reemplazar con UUID real
  name: 'Add priority to Order',
  version: '0.0.7',
  sort: 1,
  upScript: `
    ALTER TABLE public."Order" ADD COLUMN "priority" INTEGER NOT NULL DEFAULT 0;
  `,
  downScript: `
    ALTER TABLE public."Order" DROP COLUMN IF EXISTS "priority";
  `,
};

/**
 * Ejemplo: Crear procedure para generar código de orden
 *
 * 1. Copiar el template "Sequence with Idempotency" (sort: 1)
 * 2. Copiar el template "Function + Trigger con código secuencial" (sort: 2)
 * 3. Generar UUIDs
 * 4. Reemplazar placeholders
 */
const exampleProcedureSequence: ToolsCreateProcedureTemplateInput = {
  id: 'b2c3d4e5-f6a7-8901-bcde-f23456789012',
  name: 'Create order_code sequence',
  type: ToolsProcedureType.FUNCTION,
  version: '0.0.7',
  sort: 1,
  upScript: `
DO $$
BEGIN
    IF to_regclass('public.order_code_seq') IS NULL THEN
        CREATE SEQUENCE order_code_seq
            AS bigint
            START WITH 1
            INCREMENT BY 1
            NO MINVALUE
            NO MAXVALUE
            CACHE 1;
    END IF;
END
$$;
  `,
  downScript: `DROP SEQUENCE IF EXISTS order_code_seq;`,
};
