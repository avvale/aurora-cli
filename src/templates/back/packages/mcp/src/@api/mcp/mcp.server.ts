import { Injectable, OnApplicationBootstrap } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { GraphQLArgument, GraphQLInputType, GraphQLSchema, getNamedType, isInputObjectType, isListType, isNonNullType, isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, GraphQLType } from 'graphql';
import { firstValueFrom } from 'rxjs';
import { SchemaStoreService } from '@aurora/modules/graphql/schema-store.service';
import { McpAuthService } from './mcp.auth.service';

@Injectable()
export class McpNestGraphQLServer implements OnApplicationBootstrap
{
    private schema!: GraphQLSchema;
    private initialized = false;
    private initPromise?: Promise<void>;

    constructor(
        private readonly schemaStoreService: SchemaStoreService,
        private readonly http: HttpService,
        private readonly auth: McpAuthService,
    ) {}

    async onApplicationBootstrap(): Promise<void>
    {
        this.schema = await this.waitForSchema();
        this.initialized = true;
    }

    private async waitForSchema(
        timeoutMs = 15000,
        intervalMs = 50,
    ): Promise<GraphQLSchema>
    {
        const start = Date.now();
        while (true)
        {
            try
            {
                const s = this.schemaStoreService.getSchema();
                if (s) return s;
            }
            catch
            {
                // Ignore errors
            }

            if (Date.now() - start > timeoutMs) throw new Error('GraphQL schema not ready (timeout)');
            await new Promise(r => setTimeout(r, intervalMs));
        }
    }

    // Factory: create a fresh MCP server instance with all resources/tools
    createServer(): McpServer
    {
        const server = new McpServer({ name: 'nestjs-mcp', version: '1.0.0' });
        this.initFromSchema(server);
        return server;
    }

    private initFromSchema(server: McpServer): void
    {
        // 1) Resource: full GraphQL SDL
        server.registerResource(
            'graphql-schema',
            'gql://schema',
            {
                title      : 'GraphQL Schema (SDL)',
                description: `Complete GraphQL API schema in SDL format, contains metadata
                with help for the compression of fields and queries, as well as instructions
                for the composition of a QueryStatement object.`,
                mimeType: 'text/plain',
            },
            uri => ({
                contents: [{ uri: uri.href, text: this.schemaStoreService.getSDL() }],
            }),
        );

        // 1.b) Minimal prompt so clients don't error on prompts/list
        server.registerPrompt(
            'graphql-quickstart',
            {
                title      : 'GraphQL Quickstart',
                description: 'Brief help to use the GraphQL tools of this server.',
            },
            () => ({
                description: 'How to get started',
                messages   : [
                    {
                        role   : 'user',
                        content: {
                            type: 'text',
                            text: [
                                'Use the "graphql-execute" tool to execute arbitrary GraphQL documents,',
                                'or any of the "gql-query-*" generated by introspection.',
                            ].join(' '),
                        },
                    },
                ],
            }),
        );

        // 2) Tool: generic GraphQL executor (allows queries y mutations)
        server.registerTool(
            'graphql-execute',
            {
                title      : 'GraphQL execute',
                description: 'Executes GraphQL operations (queries) against this API.',
                inputSchema: {
                    document     : z.string().describe('GraphQL document/operation.'),
                    variables    : z.record(z.any()).optional(),
                    operationName: z.string().optional(),
                    headers      : z.record(z.string()).optional(),
                },
            },
            async ({ document, variables, operationName, headers }) =>
            {
                try
                {
                    const { status, data } = await this.execHttp({ document, variables, operationName, headers });
                    const text = JSON.stringify({ status, data }, null, 2);
                    return { content: [{ type: 'text', text }]};
                }
                catch (e)
                {
                    return { content: [{ type: 'text', text: String(e instanceof Error ? e.message : e) }], isError: true } as const;
                }
            },
        );

        // 3) Introspection: one tool per Query field, with INCLUDE/EXCLUDE logic
        const q = this.schema.getQueryType();
        if (q)
        {
            const include = (process.env.MCP_INCLUDE_API_TOOLS || '').trim();
            const includeAll = include.length === 0 || include === '*';
            const includeSet = new Set(includeAll ? [] : include.split(',').map(s => s.trim()).filter(Boolean));
            const excludeSet = new Set((process.env.MCP_EXCLUDE_API_TOOLS || '').split(',').map(s => s.trim()).filter(Boolean));

            const fields = q.getFields();
            for (const fieldName of Object.keys(fields))
            {
                if (!includeAll && !includeSet.has(fieldName)) continue;
                if (excludeSet.size && excludeSet.has(fieldName)) continue;

                const field = fields[fieldName];
                const args = field.args;
                const inputSchema = this.argsToZodSchema(args);
                const { varDefs, argAssigns } = this.buildVarDefsAndArgs(args);
                const selection = this.buildSelection(field.type);
                const document = `query ${fieldName}${varDefs ? `(${varDefs})` : ''} { ${fieldName}${argAssigns} ${selection} }`;

                server.registerTool(
                    `gql-query-${fieldName}`,
                    {
                        title      : `Query ${fieldName}`,
                        description: field.description ?? `GraphQL query ${fieldName}`,
                        inputSchema,
                    },
                    async toolArgs =>
                    {
                        const variables = toolArgs as Record<string, unknown>;
                        const { status, data } = await this.execHttp({ document, variables });
                        const text = JSON.stringify({ status, data }, null, 2);
                        return { content: [{ type: 'text', text }]};
                    },
                );
            }
        }

        // 4) Auth tool: password grant when env variables are not provided
        server.registerTool(
            'auth-login',
            {
                title      : 'Authentication (PASSWORD)',
                description: 'Gets JWT using grant PASSWORD when there is no MCP_AUTH_USERNAME / MCP_AUTH_CLIENT_SECRET in the environment variables',
                inputSchema: {
                    username: z.string(),
                    password: z.string(),
                },
            },
            async ({ username, password }) =>
            {
                await this.auth.loginWithPassword(username, password);
                return { content: [{ type: 'text', text: 'Login OK' }]};
            },
        );
    }

    private async execHttp(
        {
            document,
            variables,
            operationName,
            headers,
        }: {
            document: string;
            variables?: Record<string, unknown>;
            operationName?: string;
            headers?: Record<string, string>;
        },
    )
    {
        const baseURL = process.env.SELF_BASE_URL || `http://localhost:${process.env.APP_PORT || 3000}`;

        await this.auth.ensureAuth();


        const makeRequest = async (authHeader?: string) => firstValueFrom(this.http.post<any>(
            `${baseURL}/graphql`,
            { query: document, variables, operationName },
            {
                headers: {
                    'Content-Type': 'application/json',
                    ...(authHeader ? { Authorization: authHeader } : {}),
                    ...(headers ?? {}),
                },
                validateStatus: () => true,
                timeout       : 60000,
            },
        ));

        // Attempt with current token
        let res = await makeRequest(this.auth.getAuthHeader());
        if (res.status === 401)
        {
            // Try refresh flow
            const refreshed = await this.auth.refreshIfNeeded();
            if (refreshed)
            {
                res = await makeRequest(this.auth.getAuthHeader());
            }
        }
        return { status: res.status, data: res.data };
    }

    private argsToZodSchema(args: readonly GraphQLArgument[])
    {
        const shape: Record<string, z.ZodTypeAny> = {};
        for (const a of args)
        {
            const zt = this.zodFromInputType(a.type);
            shape[a.name] = isNonNullType(a.type) ? zt : zt.optional();
        }
        return shape;
    }

    /**
     * Converts a GraphQL input type to a corresponding Zod schema.
     *
     * This method recursively traverses the provided GraphQL input type and generates
     * a Zod schema that matches its structure and constraints. It supports non-null types,
     * lists, input objects, and scalar types (such as String, Boolean, Int, Float, ID, and JSON).
     * For input object types, it builds a Zod object schema with fields mapped to their respective
     * Zod types, marking fields as optional if they are nullable in the GraphQL schema.
     *
     * @param t - The GraphQL input type to convert.
     * @returns A Zod schema representing the input type.
     */
    private zodFromInputType(t: GraphQLInputType): z.ZodTypeAny
    {
        const nonNull = isNonNullType(t);
        const inner = nonNull ? t.ofType : t;

        if (isListType(inner)) return z.array(this.zodFromInputType(inner.ofType));

        const named = getNamedType(inner);
        if (isInputObjectType(named))
        {
            const fields = named.getFields();
            const shape: Record<string, z.ZodTypeAny> = {};
            for (const fName of Object.keys(fields))
            {
                const f = fields[fName];
                const fZ = this.zodFromInputType(f.type);
                shape[fName] = isNonNullType(f.type) ? fZ : fZ.optional();
            }
            return z.object(shape);
        }

        if (isScalarType(named))
        {
            switch (named.name)
            {
                case 'GraphQLString':
                case 'String':
                case 'ID':
                    return z.string();
                case 'GraphQLBoolean':
                case 'Boolean':
                    return z.boolean();
                case 'GraphQLInt':
                case 'Int':
                    return z.number().int();
                case 'GraphQLFloat':
                case 'Float':
                    return z.number();
                case 'JSON':
                    return z.record(z.any());
                default:
                    return z.string().describe(`scalar ${named.name}`);
            }
        }
        return z.unknown();
    }

    private buildVarDefsAndArgs(args: readonly GraphQLArgument[])
    {
        const varDefs: string[] = [];
        const assigns: string[] = [];
        for (const a of args)
        {
            const gType = this.gqlTypeFromInput(a.type);
            varDefs.push(`$${a.name}: ${gType}`);
            assigns.push(`${a.name}: $${a.name}`);
        }
        return { varDefs: varDefs.join(', '), argAssigns: args.length ? `(${assigns.join(', ')})` : '' };
    }

    // Build a reasonable selection set for a given output type
    // - Scalars/Enums: no selection
    // - Objects/Interfaces: first-level scalar/enum fields (preferring `id` if exists)
    // - Lists: unwrap and apply same logic to item type
    // - Unions: __typename
    private buildSelection(t: GraphQLType): string
    {
        // unwrap list/non-null wrappers
        let inner: any = t as any;
        while (isNonNullType(inner) || isListType(inner)) inner = inner.ofType;

        const named = getNamedType(inner);

        // Scalars or Enums do not take a sub-selection
        if (isScalarType(named) || isEnumType(named)) return '';

        // Unions: safest is asking for __typename
        if (isUnionType(named)) return '{ __typename }';

        // Objects and Interfaces: pick scalar/enum fields
        if (isObjectType(named) || isInterfaceType(named))
        {
            const fields = named.getFields();
            const fieldNames = Object.keys(fields);

            const selections: string[] = [];
            if (fieldNames.includes('id')) selections.push('id');

            for (const fname of fieldNames)
            {
                if (fname === 'id') continue;
                const fType = getNamedType(fields[fname].type);
                if (isScalarType(fType) || isEnumType(fType)) selections.push(fname);
            }

            // Fallback to typename if we couldn't find anything
            if (selections.length === 0) selections.push('__typename');
            return `{ ${selections.join(' ')} }`;
        }

        // Default: no selection
        return '';
    }

    private gqlTypeFromInput(t: GraphQLInputType): string
    {
        if (isNonNullType(t)) return `${this.gqlTypeFromInput(t.ofType)}!`;
        if (isListType(t)) return `[${this.gqlTypeFromInput(t.ofType)}]`;
        const named = getNamedType(t);
        if (isScalarType(named))
        {
            switch (named.name)
            {
                case 'GraphQLString':
                case 'String':
                case 'ID':
                    return 'String';
                case 'GraphQLBoolean':
                case 'Boolean':
                    return 'Boolean';
                case 'GraphQLInt':
                case 'Int':
                    return 'Int';
                case 'GraphQLFloat':
                case 'Float':
                    return 'Float';
                default:
                    return named.name;
            }
        }

        if (isInputObjectType(named)) return named.name;
        return 'String';
    }
}
